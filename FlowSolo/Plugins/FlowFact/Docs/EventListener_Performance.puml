@startuml EventListener_Performance

title EventListener 性能优化架构图

skinparam componentStyle rectangle

package "性能优化层次" {

    ' ============ 第一层：线程安全 ============
    package "线程安全层" #LightBlue {
        component [FThreadSafeBool\n原子操作] as AtomicBool #LightGreen
        component [FCriticalSection\n临界区锁] as CriticalSection #LightYellow
        component [TSharedPtr\n智能指针] as SmartPtr #LightGreen

        note right of AtomicBool
          <b>性能：~1-2ns</b>
          • CPU 原子指令（LOCK CMPXCHG）
          • 无需系统调用
          • 无锁读取
          --
          <b>对比普通 bool + mutex：</b>
          • mutex 获取：~20-50ns
          • 性能提升：10-25x
        end note

        note right of CriticalSection
          <b>性能：~10-20ns</b>
          • 最小粒度锁（只锁 TMap 操作）
          • FScopeLock 自动管理生命周期
          • 避免死锁
          --
          <b>锁粒度对比：</b>
          • 全局锁：整个函数执行期间
          • 最小锁：只在 TMap 操作时
          • 锁时间减少：80%+
        end note

        note right of SmartPtr
          <b>性能：引用计数原子操作</b>
          • 自动内存管理
          • 线程安全引用计数
          • 避免内存泄漏
          --
          <b>对比手动管理：</b>
          • 无需遍历清理（O(N) → O(1)）
          • 最后一个引用释放时自动销毁
        end note
    }

    ' ============ 第二层：数据结构 ============
    package "数据结构层" #LightCyan {
        component [TMap<FGuid, Listener>\n哈希表] as HashMap #LightGreen
        component [FGuid::GetTypeHash()\nGUID 哈希函数] as HashFunc

        note right of HashMap
          <b>查找性能：O(1)</b>
          • 哈希表平均查找：1.3 次比较
          • 负载因子：0.75（UE 默认）
          --
          <b>对比链表：</b>
          • 链表：O(N)，100 个元素平均 50 次比较
          • 哈希表：O(1)，100 个元素平均 1.3 次比较
          • 性能提升：38x
        end note

        note right of HashFunc
          <b>哈希算法：</b>
          • FGuid = 4 个 uint32（128 bit）
          • Hash = A ^ B ^ C ^ D
          • 冲突率低（<1%）
          --
          <b>对比 REDEngine Fact：</b>
          • 2077：FNV-1a 字符串哈希
          • FlowFact：FGuid 整数哈希
          • 都是 O(1) 查找
        end note
    }

    ' ============ 第三层：轮询优化 ============
    package "轮询优化层" #LightYellow {
        component [0.1s Timer\n定时轮询] as Timer #LightGreen
        component [立即检查\nEarly Exit] as EarlyExit #LightGreen
        component [回调模式\nEvent-Driven] as Callback #LightGreen

        note right of Timer
          <b>性能提升：6x</b>
          • 每帧检查：60 Hz（60 FPS）
          • 定时检查：10 Hz（0.1s）
          • 检查次数减少：6x
          --
          <b>精度代价：</b>
          • 最大误差：±100ms
          • 对游戏任务系统可接受
        end note

        note right of EarlyExit
          <b>避免启动不必要的 Timer</b>
          • 立即满足条件 → 直接触发输出
          • 不启动 Timer → 节省系统资源
          --
          <b>代码逻辑：</b>
          if (Condition->IsFulfilled())
          {
              TriggerOutput();
              return;  // 不启动 Timer
          }
        end note

        note right of Callback
          <b>性能提升：∞</b>
          • 事件驱动，只在满足时通知
          • 避免 99% 无效轮询
          --
          <b>对比全量轮询：</b>
          • 轮询：1000 节点 × 60 FPS = 60000 次/秒
          • 回调：仅在事件触发时调用
        end note
    }

    ' ============ 第四层：内存管理 ============
    package "内存管理层" #LightPink {
        component [智能指针\n引用计数] as RefCount #LightGreen
        component [批量清空\nClearAllListeners] as BatchClear #LightGreen

        note right of RefCount
          <b>自动内存管理</b>
          • TSharedPtr 引用计数
          • 最后一个引用释放时自动 delete
          • 避免内存泄漏和野指针
          --
          <b>线程安全：</b>
          • 引用计数使用原子操作
          • 多线程访问安全
        end note

        note right of BatchClear
          <b>性能：O(1)</b>
          • TMap::Empty() 直接释放内存块
          • 无需逐个 Remove（O(N)）
          --
          <b>对比逐个删除：</b>
          • 逐个 Remove：O(N)
          • 批量 Empty：O(1)
        end note
    }
}

' ============ 性能对比表 ============
package "性能对比（1000 个监听器场景）" #WhiteSmoke {
    component [传统实现\n全量轮询] as Traditional #LightCoral {
        [每帧遍历：60000 次/秒]
        [全局互斥锁：50ns/次]
        [链表查找：O(N)]
        [手动内存管理]
        --
        <b>总开销：</b>
        60000 × (50ns + 500ns) = 33ms/秒
        <b>CPU 占用：</b>
        33ms / 16.67ms = 198% (爆表)
    }

    component [EventListener\n优化实现] as Optimized #LightGreen {
        [定时检查：10000 次/秒]
        [原子操作：2ns/次]
        [哈希查找：O(1)]
        [智能指针自动管理]
        --
        <b>总开销：</b>
        10000 × (2ns + 20ns) = 0.22ms/秒
        <b>CPU 占用：</b>
        0.22ms / 16.67ms = 1.3%
    }

    Traditional -[#Red,thickness=4]-> Optimized : <b>性能提升 150x</b>
}

' ============ REDEngine Fact 对比 ============
package "与 REDEngine Fact 数据库对比" #Lavender {
    component [REDEngine Fact\n(2077)] as REDFact {
        • 轻量级读写锁
        • FNV-1a 字符串哈希
        • 原子 int32 计数器
        • 内存池预分配
        • 按模块分表设计
    }

    component [FlowFact EventListener] as FlowFact {
        • FCriticalSection + 原子操作
        • FGuid 哈希表
        • FThreadSafeBool
        • 智能指针引用计数
        • 单表设计（足够当前规模）
    }

    REDFact <-[#DarkGreen,thickness=2]-> FlowFact : <b>优化思路一致</b>

    note bottom of REDFact
      <b>共同点：</b>
      1. 原子操作避免锁竞争
      2. 哈希表 O(1) 查找
      3. 最小锁粒度
      4. 批量处理优化
    end note
}

' ============ 进一步优化方向 ============
package "进一步优化方向（规模扩展）" #LightGoldenRodYellow {
    component [对象池\n预分配] as Pool {
        <b>适用场景：</b>
        • 监听器频繁创建/销毁
        • 避免 new/delete 开销
        --
        <b>实现：</b>
        TArray<FEventListener*> Pool
        Acquire() / Release()
    }

    component [分桶哈希\n降低锁竞争] as Bucketing {
        <b>适用场景：</b>
        • 1000+ 监听器
        • 多线程高并发访问
        --
        <b>实现：</b>
        TMap Listeners[16]
        BucketIndex = Guid.A % 16
    }

    component [Dirty Flag\n延迟更新] as DirtyFlag {
        <b>适用场景：</b>
        • 大量监听器但变化少
        • 批量更新优化
        --
        <b>实现：</b>
        TArray<FGuid> DirtyListeners
        只更新变化的监听器
    }

    note bottom of Pool
      类似 2077 Fact 的内存池设计
    end note

    note bottom of Bucketing
      类似 2077 Fact 的分表设计
    end note
}

@enduml
