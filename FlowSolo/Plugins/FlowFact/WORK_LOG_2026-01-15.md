# FlowFact 工作日志 - 2026-01-15

## 会话概述
本次会话完成了Wait-Continue-Condition系统从FlowFact模块到FlowFactCore公共模块的迁移，使其可以被其他模块跨模块调用。

---

## 背景信息

### 项目结构
- **工作目录**: F:\Data\UE_Project\FlowSolo\FlowSolo
- **插件**: FlowFact (位于 Plugins/FlowFact/)
- **Git分支**: FlowSoloJaosn
- **主分支**: 5.6

### 初始问题
用户发现FlowFact模块中的Condition系统无法被其他模块使用，因为：
1. 虽然FlowFactEditor不需要导出宏也能调用FlowFact（同一插件内部）
2. 但跨插件/模块调用时会出现链接问题
3. 需要创建一个公共的FlowFactCore模块来存放通用系统

---

## 完成的工作

### 1. 创建FlowFactCore模块

#### 模块结构
```
FlowFact/Source/FlowFactCore/
├── FlowFactCore.Build.cs
├── Public/
│   ├── FlowFactCore.h
│   ├── Condition/
│   │   ├── ICondition.h
│   │   ├── TimeCondition.h
│   │   └── CustomCondition.h
│   └── WaitContinue/
│       ├── WaitContinueTypes.h
│       ├── ExecutionContext.h
│       └── EventListener.h
└── Private/
    ├── FlowFactCore.cpp
    └── WaitContinue/
        └── ExecutionContext.cpp
```

#### FlowFactCore.Build.cs 内容
```csharp
using UnrealBuildTool;

public class FlowFactCore : ModuleRules
{
    public FlowFactCore(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

        PublicDependencyModuleNames.AddRange(
            new string[]
            {
                "Core",
            }
        );

        PrivateDependencyModuleNames.AddRange(
            new string[]
            {
                "CoreUObject",
                "Engine",
            }
        );
    }
}
```

#### 模块类实现
**FlowFactCore.h**:
```cpp
#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

class FFlowFactCoreModule : public IModuleInterface
{
public:
    virtual void StartupModule() override;
    virtual void ShutdownModule() override;
};
```

**FlowFactCore.cpp**:
```cpp
#include "FlowFactCore.h"

#define LOCTEXT_NAMESPACE "FFlowFactCoreModule"

void FFlowFactCoreModule::StartupModule()
{
}

void FFlowFactCoreModule::ShutdownModule()
{
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FFlowFactCoreModule, FlowFactCore)
```

---

### 2. 迁移Condition系统文件

#### 从 FlowFact 迁移到 FlowFactCore

**迁移的文件列表**:

1. **Condition系统**:
   - `ICondition.h` - 条件接口和基类
   - `TimeCondition.h` - 时间延迟条件
   - `CustomCondition.h` - 自定义条件

2. **WaitContinue系统**:
   - `WaitContinueTypes.h` - 类型定义
   - `EventListener.h` - 事件监听器
   - `ExecutionContext.h` - 执行上下文（头文件）
   - `ExecutionContext.cpp` - 执行上下文（实现文件）

#### 关键修改

**ExecutionContext.h** - 更新API宏:
```cpp
// 从
class FLOWFACT_API FExecutionContext

// 改为
class FLOWFACTCORE_API FExecutionContext
```

---

### 3. 清理旧文件

删除了FlowFact模块中的旧文件:
```bash
rm -rf FlowFact/Source/FlowFact/Public/Condition
rm -rf FlowFact/Source/FlowFact/Public/WaitContinue
rm -rf FlowFact/Source/FlowFact/Private/WaitContinue
```

---

### 4. 更新模块依赖关系

#### FlowFact.Build.cs
添加FlowFactCore依赖:
```csharp
PublicDependencyModuleNames.AddRange(
    new string[]
    {
        "Core", "Flow", "FlowFactCore",  // 添加了 FlowFactCore
    }
);
```

#### FlowFactEditor.Build.cs
添加FlowFactCore依赖:
```csharp
PublicDependencyModuleNames.AddRange(
    new string[]
    {
        "Core",
        "Flow",
        "FlowFactCore",  // 添加了 FlowFactCore
    }
);
```

---

### 5. 更新插件配置

#### FlowFact.uplugin
注册FlowFactCore模块:
```json
{
    "Modules": [
        {
            "Name": "FlowFactCore",
            "Type": "Runtime",
            "LoadingPhase": "Default"
        },
        {
            "Name": "FlowFact",
            "Type": "Runtime",
            "LoadingPhase": "Default"
        },
        {
            "Name": "FlowFactEditor",
            "Type": "Editor",
            "LoadingPhase": "Default"
        }
    ]
}
```

注意：FlowFactCore放在最前面，确保其他模块加载前先加载。

---

## 技术要点

### API导出宏的使用规则

1. **Header-Only类** (所有实现都在.h文件中):
   - 不需要XXX_API宏
   - 例如: FEventListener, ICondition, FBaseCondition, FTimeCondition, FCustomCondition

2. **有.cpp实现的类**:
   - 需要XXX_API宏
   - 例如: FExecutionContext (FLOWFACTCORE_API)

3. **同一插件内的模块**:
   - 不需要导出宏也能互相调用
   - 例如: FlowFactEditor 可以直接使用 FlowFact

4. **跨插件/模块调用**:
   - 必须使用正确的API导出宏
   - 例如: 其他插件使用FlowFactCore需要FLOWFACTCORE_API

### 线程安全实现

**ExecutionContext使用UE5的线程安全机制**:
```cpp
class FLOWFACTCORE_API FExecutionContext
{
private:
    mutable FCriticalSection CriticalSection;  // 互斥锁
    TMap<FGuid, TSharedPtr<FEventListener>> Listeners;
};

// 使用FScopeLock保护临界区
void FExecutionContext::RegisterListener(const FGuid& NodeId, TSharedPtr<FEventListener> Listener)
{
    FScopeLock Lock(&CriticalSection);  // RAII模式，自动加锁解锁
    Listeners.Add(NodeId, Listener);
}
```

**EventListener使用原子布尔值**:
```cpp
class FEventListener
{
protected:
    FThreadSafeBool bFulfilled;  // 原子操作，线程安全
};
```

---

## Wait-Continue-Condition系统架构

### 核心组件

1. **ICondition (接口)**:
   - `CreateEventListener()` - 创建事件监听器
   - `IsFulfilled()` - 检查条件是否满足
   - `CheckImmediately()` - 立即检查（不使用监听器）
   - `GetFriendlyName()` - 获取友好名称

2. **FBaseCondition (基类)**:
   - 实现了ICondition的默认行为
   - 提供NodeId管理
   - 子类只需重载必要的方法

3. **FEventListener (监听器)**:
   - 监控条件状态
   - 使用FThreadSafeBool保证线程安全
   - 支持回调函数

4. **FExecutionContext (执行上下文)**:
   - 管理所有事件监听器
   - 提供注册/注销/查找接口
   - 使用FCriticalSection保证线程安全

### 条件类型

1. **FTimeCondition (时间条件)**:
   - 等待指定秒数
   - FTimeEventListener每帧检查elapsed time
   - 不支持CheckImmediately

2. **FCustomCondition (自定义条件)**:
   - 接受TFunction<bool()>作为检查函数
   - 支持Lambda表达式
   - 灵活性最高

### 使用示例

在FlowNode中使用:
```cpp
UCLASS()
class UFlowNode_WaitContinue : public UFlowNode
{
    UPROPERTY()
    float DelaySeconds;

    WaitContinueSystem::FExecutionContext ExecutionContext;
    TSharedPtr<WaitContinueSystem::ICondition> CurrentCondition;

    virtual void ExecuteInput(const FName& PinName) override
    {
        // 创建条件
        CurrentCondition = MakeShared<WaitContinueSystem::FTimeCondition>(
            NodeGuid, DelaySeconds);

        // 创建并注册监听器
        auto Listener = CurrentCondition->CreateEventListener(ExecutionContext);
        ExecutionContext.RegisterListener(NodeGuid, Listener);

        // 开始定时检查
        GetWorld()->GetTimerManager().SetTimer(
            UpdateTimerHandle, this,
            &UFlowNode_WaitContinue::CheckCondition,
            0.1f, true);
    }

    void CheckCondition()
    {
        if (CurrentCondition->IsFulfilled(ExecutionContext))
        {
            // 条件满足，触发输出
            TriggerOutput(TEXT("Out"), true);
            Cleanup();
        }
    }
};
```

---

## 文件对照表

### 已读取的文件

| 文件路径 | 用途 |
|---------|------|
| `FlowFactCore/Public/Condition/CustomCondition.h` | 验证文件复制 |
| `FlowFactCore/Public/Condition/TimeCondition.h` | 验证文件复制 |
| `FlowFactCore/Public/Condition/ICondition.h` | 验证文件复制 |
| `FlowFactCore/Private/FlowFactCore.cpp` | 验证模块实现 |
| `FlowFactCore/Public/FlowFactCore.h` | 验证模块头文件 |
| `FlowFactCore/Private/WaitContinue/ExecutionContext.cpp` | 更新API宏 |
| `FlowFactCore/Public/WaitContinue/ExecutionContext.h` | 更新API宏 |
| `FlowFact/FlowFact.Build.cs` | 添加依赖 |
| `FlowFactEditor/FlowFactEditor.Build.cs` | 添加依赖 |
| `FlowFact.uplugin` | 注册模块 |

### 已修改的文件

| 文件路径 | 修改内容 |
|---------|---------|
| `FlowFactCore/Public/WaitContinue/ExecutionContext.h` | FLOWFACT_API → FLOWFACTCORE_API |
| `FlowFact/FlowFact.Build.cs` | 添加 "FlowFactCore" 依赖 |
| `FlowFactEditor/FlowFactEditor.Build.cs` | 添加 "FlowFactCore" 依赖 |
| `FlowFact.uplugin` | 添加 FlowFactCore 模块注册 |

### 已删除的目录

| 目录路径 | 原因 |
|---------|------|
| `FlowFact/Source/FlowFact/Public/Condition/` | 迁移到FlowFactCore |
| `FlowFact/Source/FlowFact/Public/WaitContinue/` | 迁移到FlowFactCore |
| `FlowFact/Source/FlowFact/Private/WaitContinue/` | 迁移到FlowFactCore |

---

## 历史问题解决

### 问题1: 纯虚函数未实现
**用户反馈**: "ICondition的子类的纯虚函数没有被重载"

**问题分析**:
- FBaseCondition只实现了IsFulfilled()
- CreateEventListener()、CheckImmediately()、GetFriendlyName()未实现

**解决方案**:
在FBaseCondition中添加了所有纯虚函数的默认实现:
```cpp
class FBaseCondition : public ICondition
{
    virtual TSharedPtr<FEventListener> CreateEventListener(FExecutionContext& Context) override
    {
        return MakeShared<FEventListener>();
    }

    virtual bool CheckImmediately(FExecutionContext& Context) const override
    {
        return false;
    }

    virtual FString GetFriendlyName() const override
    {
        return TEXT("Base Condition");
    }
};
```

### 问题2: API宏使用错误
**用户反馈**: "为什么有的AI让我删除XXX_API宏"

**问题分析**:
- Header-only类被错误地添加了API宏
- 导致__declspec(dllimport)错误

**解决方案**:
- 移除了所有header-only类的API宏
- 只保留FExecutionContext的API宏（有.cpp实现）

规则总结:
```cpp
// ❌ 错误 - Header-only类不需要API宏
class FLOWFACT_API FEventListener { ... };

// ✅ 正确 - Header-only类
class FEventListener { ... };

// ✅ 正确 - 有.cpp实现的类需要API宏
class FLOWFACTCORE_API FExecutionContext { ... };
```

### 问题3: 模块宏对应错误
**用户反馈**: "等等，为什么要加这个宏，这个宏和所在的模块对了吗"

**问题分析**:
- 在移动文件之前就想改API宏
- 应该先移动文件，再改宏

**解决方案**:
- 先复制所有文件到FlowFactCore
- 再将ExecutionContext.h的FLOWFACT_API改为FLOWFACTCORE_API
- 然后删除旧文件

---

## 下一步操作

### 必须执行的步骤

1. **重新生成项目文件**:
   - 右键点击FlowSolo.uproject
   - 选择"Generate Visual Studio project files"

2. **编译插件**:
   - 打开Visual Studio
   - 重新编译FlowFact插件
   - 确保没有链接错误

3. **验证功能**:
   - 测试FlowNode_WaitContinue节点
   - 确保时间延迟功能正常
   - 检查自定义条件功能

### 可选的后续工作

1. **添加更多条件类型**:
   - FEventCondition - 监听游戏事件
   - FBoolCondition - 监听布尔变量
   - FDistanceCondition - 监听距离变化

2. **改进FlowNode_WaitContinue**:
   - 添加多种条件类型选择
   - 支持条件组合（AND/OR）
   - 添加超时机制

3. **文档和注释**:
   - 为公共接口添加详细注释
   - 创建使用示例文档
   - 添加API参考文档

---

## 技术笔记

### UE5模块系统

**模块类型**:
- Runtime: 运行时模块，可在游戏和编辑器中使用
- Editor: 编辑器专用模块
- Developer: 开发工具模块

**依赖关系**:
```
FlowFactEditor (Editor)
    ↓ 依赖
FlowFact (Runtime) → FlowFactCore (Runtime)
    ↓ 依赖              ↓ 依赖
Flow (Runtime)      Core (Runtime)
```

**加载顺序**:
1. FlowFactCore (LoadingPhase: Default)
2. FlowFact (LoadingPhase: Default)
3. FlowFactEditor (LoadingPhase: Default)

### 命名规范

**模块命名**:
- 模块名: FlowFactCore
- API宏: FLOWFACTCORE_API
- 模块类: FFlowFactCoreModule

**文件结构**:
```
ModuleName/
├── ModuleName.Build.cs
├── Public/
│   └── ModuleName.h
└── Private/
    └── ModuleName.cpp
```

---

## Git提交信息

建议的commit message:
```
feat: 创建FlowFactCore公共模块并迁移Condition系统

- 创建FlowFactCore Runtime模块
- 迁移Wait-Continue-Condition系统到FlowFactCore
- 更新ExecutionContext使用FLOWFACTCORE_API
- 删除FlowFact中的旧Condition/WaitContinue文件
- 更新FlowFact和FlowFactEditor的模块依赖
- 更新FlowFact.uplugin注册FlowFactCore模块

现在Condition系统可以被其他插件跨模块使用
```

---

## 总结

### 成功完成的目标
✅ 创建了独立的FlowFactCore公共模块
✅ 成功迁移Wait-Continue-Condition系统
✅ 配置了正确的模块依赖关系
✅ 清理了旧文件避免冲突
✅ 更新了API导出宏
✅ 支持跨模块调用

### 解决的关键问题
- API宏的正确使用（header-only vs 有.cpp实现）
- 模块依赖和加载顺序
- 线程安全实现（FCriticalSection + FThreadSafeBool）
- UE5模块系统的正确配置

### 遵循的最佳实践
- 公共系统放在独立的Core模块中
- Header-only类不使用API导出宏
- 使用RAII模式管理锁（FScopeLock）
- 模块按功能分层（Core → Runtime → Editor）

---

**文档创建时间**: 2026-01-15
**最后更新**: 2026-01-15
**作者**: Claude Code AI Assistant
